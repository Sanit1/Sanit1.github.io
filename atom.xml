<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanit的代码窝</title>
  
  <subtitle>一个后端小小程序员的代码窝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Sanit1.github.io/"/>
  <updated>2019-07-21T14:35:19.904Z</updated>
  <id>https://Sanit1.github.io/</id>
  
  <author>
    <name>Sanit</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Laravel依赖注入的实现</title>
    <link href="https://Sanit1.github.io/2017/01/08/Laravel%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html"/>
    <id>https://Sanit1.github.io/2017/01/08/Laravel依赖注入的实现/index.html</id>
    <published>2017-01-08T14:21:00.000Z</published>
    <updated>2019-07-21T14:35:19.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是依赖注入？其实这个特性在这个框架各个地方都有体现，实现代码的解耦。就是A类里面的需要依赖到B类，依赖注入的话A类中只依赖接口，而在A类实例化的时候注入实现接口的B类，大大降低了代码的耦合。</p></blockquote><a id="more"></a><h3 id="php简单的依赖注入实现"><a href="#php简单的依赖注入实现" class="headerlink" title="php简单的依赖注入实现"></a>php简单的依赖注入实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send();</span><br><span class="line">&#125;</span><br><span class="line">class SMS implements Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;send SMS&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Voice implements Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;send Voice&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User</span><br><span class="line">&#123;</span><br><span class="line">    public function sendNotify(Notify $notify)</span><br><span class="line">    &#123;</span><br><span class="line">        $notify-&gt;send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$user = new User;</span><br><span class="line">$user-&gt;sendNotify(new SMS);</span><br></pre></td></tr></table></figure><p>这里我简化了日常的业务逻辑。我们要对一个用户发送通知，可以用短信发送也可以通过语音发送等等。如果不用依赖注入，我们直接在User类你们new一个SMS或者Voice类。当然也是没问题的。但是突然有一天，老板说改成Email对用户发送通知，好了 我们User类要改，具体调用user类的地方也要改。当然实际的业务逻辑更复杂。在日积月累的情况下代码就变得更不好维护了。依赖注入让我们的业务中调用的是接口，而不是具体的类，实现了代码的解耦。这样子，就算老板让我们改成用邮件对用户发送通知，我们只要新建个实现了Notify接口的Email类，然后在具体调用的时候传这个Email类过去就行了。</p><h3 id="Laravel中依赖注入的实现"><a href="#Laravel中依赖注入的实现" class="headerlink" title="Laravel中依赖注入的实现"></a>Laravel中依赖注入的实现</h3><p>在用Laravel框架的时候，我们在控制器只要把类注入进去，就能直接调用，貌似没有看到具体在哪里new的。那是因为Laraver的控制器要求你都要继承它的BaseController。框架在运行的时候直接从容器中解析你注入进去的类给你实例化了。什么是容器，就是一个智能并高级的工厂。Laravel框架在启动的时候会把你配置文件的类实例化到容器内。容器可以通过闭包、PHP的反射类<code>ReflectionClass</code>来解析出具体的对象。所以我们就看不到具体在使用Laravel的时候，看它一直在注入类，却看不到它具体是在哪里new的。</p><p><strong>容器类(Container)的原理</strong></p><p>Larvel的容器类在/vendor/laravel/framework/src/Illuminate/Container/Container。我们打开可以看到一个非常长的类。咋一看不知道干嘛的，看不懂，一开始我也是。所以我简化了下容器，自己写了个容器类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected $bindings = [];</span><br><span class="line">    public function bind($abstract, $concrete = null, $shared = false)</span><br><span class="line">    &#123;</span><br><span class="line">        if(! $concrete instanceof Closure)&#123;</span><br><span class="line">            $concrete = $this-&gt;getClosure($abstract,$concrete);</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;bindings[$abstract] = compact(&apos;concrete&apos;, &apos;shared&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    public function getClosure($abstract, $concrete)</span><br><span class="line">    &#123;</span><br><span class="line">        return function($c, $parameters = []) use ($abstract, $concrete)</span><br><span class="line">        &#123;</span><br><span class="line">            $method = ($abstract == $concrete) ? &apos;build&apos; : &apos;make&apos;;</span><br><span class="line">            return $c-&gt;$method($concrete,$parameters);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function make($abstract,$parameters = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $concrete = $this-&gt;getConcrete($abstract);</span><br><span class="line">        if ($this-&gt;isBuildable($concrete, $abstract)) &#123;</span><br><span class="line">            $object = $this-&gt;build($concrete,$parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $object = $this-&gt;make($concrete,$parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        return $object;</span><br><span class="line">    &#125;</span><br><span class="line">    protected function isBuildable($concrete, $abstract)</span><br><span class="line">    &#123;</span><br><span class="line">        return $concrete === $abstract || $concrete instanceof Closure;</span><br><span class="line">    &#125;</span><br><span class="line">    protected function getConcrete($abstract)</span><br><span class="line">    &#123;</span><br><span class="line">        if(! isset($this-&gt;bindings[$abstract]))</span><br><span class="line">        &#123;</span><br><span class="line">            return $abstract;</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;bindings[$abstract][&apos;concrete&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    public function build($concrete,$parameters=[])</span><br><span class="line">    &#123;</span><br><span class="line">        if($concrete instanceof Closure)&#123;</span><br><span class="line">            return $concrete($this,$parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        $reflector = new ReflectionClass($concrete);</span><br><span class="line">        if(! $reflector-&gt;isInstantiable()) &#123;</span><br><span class="line">            return $message= &quot;Target [$concrete] is not instantiable.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $constructor = $reflector-&gt;getConstructor();</span><br><span class="line">        if (is_null($constructor)) &#123;</span><br><span class="line">            return new $concrete;</span><br><span class="line">        &#125;</span><br><span class="line">        $dependencies = $constructor-&gt;getParameters();</span><br><span class="line">        $instances = $this-&gt;getDependencies($dependencies,$parameters);</span><br><span class="line">        return $reflector-&gt;newInstanceArgs($instances);</span><br><span class="line">    &#125;</span><br><span class="line">    protected function getDependencies($parameters,array $primitives = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $dependencies = [];</span><br><span class="line">        foreach ($parameters as $parameter)</span><br><span class="line">        &#123;</span><br><span class="line">            $dependency = $parameter-&gt;getClass();</span><br><span class="line">            if(array_key_exists($parameter-&gt;name,$primitives))&#123;</span><br><span class="line">                $dependencies[] = $primitives[$parameter-&gt;name];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(is_null($dependency))&#123;</span><br><span class="line">                $dependencies[] = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                $dependencies[] = $this-&gt;resolveClass($parameter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (array) $dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">    protected function resolveClass(ReflectionParameter $parameter)</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;make($parameter-&gt;getClass()-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send();</span><br><span class="line">&#125;</span><br><span class="line">class SMS implements Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;SMS send&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mail implements Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;Mail send&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Push implements Notify</span><br><span class="line">&#123;</span><br><span class="line">    public function send()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;Push send&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Message</span><br><span class="line">&#123;</span><br><span class="line">    protected $notifyTool;</span><br><span class="line">    protected $config;</span><br><span class="line">    public function __construct(Notify $notify,$parameters = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;notifyTool = $notify;</span><br><span class="line">        $this-&gt;config = $parameters;</span><br><span class="line">    &#125;</span><br><span class="line">    public function sendMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;notifyTool-&gt;send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$app = new Container();</span><br><span class="line">$app-&gt;bind(&apos;Notify&apos;,&apos;Sms&apos;);</span><br><span class="line">$app-&gt;bind(&apos;message&apos;,&apos;Message&apos;);</span><br><span class="line">$msg = $app-&gt;make(&apos;message&apos;,[&apos;parameters&apos;=&gt;&apos;额外参数&apos;]);</span><br><span class="line">$msg-&gt;sendMessage();</span><br></pre></td></tr></table></figure><p>容器的实现过程主要依赖php的反射类，一个参数传过来的时候，通过反射可以知道这个类是否可以被实例化，方法存不存在。你看,这样的话我们是不是基本上没有new了。其实不是没new了，而是通过反射，只要写好这样一个通用的容器，new的过程还是有的，只不过都在容器里面了。我写的这个容器还是要通过手动绑定参数来实现，Laravel的服务容器当然更高级，Laravel容器的核心代码基本都在我这里体现了。Laravel的容器能根据类的依赖需求，自动在已经注册、绑定的一堆实例中找到符合需求的，自动注入。</p><p>到这里，依赖注入的实现基本上也讲完了。Laravel还有个Facade(门面),其实我感觉这个没多大用,但是有些人在刚接触Laravel的时候有困惑，我稍微带过一下。门面其实把容器里面绑定好的类再套一层，然后用php的魔术方法__callStatic()来实现像是静态的调用不是静态的各个方法。</p><h3 id="更多关于容器IOC的文章"><a href="#更多关于容器IOC的文章" class="headerlink" title="更多关于容器IOC的文章"></a>更多关于容器IOC的文章</h3><p><a href="http://laravelacademy.org/post/769.html" target="_blank" rel="noopener">http://laravelacademy.org/post/769.html</a></p><p><a href="https://segmentfault.com/a/1190000002411255" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002411255</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;什么是依赖注入？其实这个特性在这个框架各个地方都有体现，实现代码的解耦。就是A类里面的需要依赖到B类，依赖注入的话A类中只依赖接口，而在A类实例化的时候注入实现接口的B类，大大降低了代码的耦合。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="IOC容器" scheme="https://Sanit1.github.io/tags/IOC%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker的简单使用</title>
    <link href="https://Sanit1.github.io/2016/12/01/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/index.html"/>
    <id>https://Sanit1.github.io/2016/12/01/Docker的简单使用/index.html</id>
    <published>2016-12-01T14:36:00.000Z</published>
    <updated>2019-07-21T15:28:26.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近这个docker容器很火。好多牛逼的公司拿它来布置各样的环境啊，布置分布式啊等等。当然，作为码畜的我，玩的没其它人高级。正好公司要求线上环境要跟自己的开发环境保持一致，我就用上了docker</p></blockquote><a id="more"></a><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>根据百度百科的定义:Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。其实docker就是一个容器的概念，这个容器可以运行各种镜像。比如你线上的环境是lnmp,你可以打包成一个docker镜像，你自己做负载或者要求多台服务器环境一样的时候，每台装个docker。然后run同样的镜像，那么就能保持各个环境的一致。而且你一台服务器可以跑多个镜像哦。</p><h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><p>Docker的安装也很简单，我们打开<a href="https://www.docker.com/" target="_blank" rel="noopener">docker官网</a>。官网有介绍docker的安装。我简单的来说明一下吧。如果你的电脑是Windows操作系统，最好升级到win10,docker在不是win10专业版或者企业版的电脑上也可以跑，不过这时候你是没法安装docker for windows的，这时候，docker是要在virtualbox运行的。也就相当于你Windows开了个虚拟机来跑docker.我上述讲的那两个版本的Windows能跑docker是因为win10自带虚拟机——Hyper-V。所以能运行docker.至于在linux下的安装，我主要用的Centos，你要想安装docker,你得把你的linux内核升到3以上。大部分人用的都是Centos6.5.他的内核是基于linux2.6的。如果你用的是Centos7.那你什么都不用管，可以直接安装，如果用的是6.5的，你可以选择换成7或者你可以在不升级操作系统，只升级它的内核。至于具体怎么升级，这里不展开讲，我有空也会在我的博客更新的。其实百度下有很多，只不过都是良莠不齐。具体的安装过程很简单，只要你满足我上述讲的条件的机子，因为比较穷，玩不起mac,没在mac下安装过，基本上几分钟就安装好了。<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">docker安装过程</a></p><h3 id="运行docker容器"><a href="#运行docker容器" class="headerlink" title="运行docker容器"></a>运行docker容器</h3><p>安装好Docker后，我们得有个镜像才能让容器跑起来(Windows下直接打开cmd命令行)。首先我们先登录一个docker仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=xxxxx</span><br></pre></td></tr></table></figure></p><p>然后根据提示输入密码，登录成功。然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称:镜像tag</span><br></pre></td></tr></table></figure><p>阿里云有免费的docker仓库，我就拿来用了。然后你需要做的就是等待镜像下载好。下载好后，我们可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -a</span><br></pre></td></tr></table></figure></p><p>查看已经下载的镜像。如果你直接docker pull的话，应该是从dockerhub上载公共镜像的<br><img src="\images/dockerPull.png" alt="docker_pulll"></p><p>这就是我下载好的镜像。我们怎么把它跑起来呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name work  -p  80:80  -v d:/work/:/dockerdata/www/ registry.cn-hangzhou.aliyuncs.com/hsn/lnmp:160930</span><br></pre></td></tr></table></figure><p>我主要讲下几个重要的参数 –name是指你要跑起来容器的名字，-p是端口映射的意思，就是把本机的80端口映射到虚拟机里面的80端口，-v是绑定目录的意思，就是把你本机的目录绑定到docker容器里面。后面跟的就是你的镜像。run好我们的容器之后，我们开始进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 你run的容器名字</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it  你run的容器名字 /bin/bash</span><br></pre></td></tr></table></figure></p><p>这时候我们就进入了我们run起来的容器了。<code>attach</code>进去的话你开多个终端会有点问题这里推荐使用<code>exec</code>。<br><a href="https://www.infoq.cn/article/docker-command-line-quest/" target="_blank" rel="noopener">更多docker run参数说明参考</a></p><h3 id="在docker容器里面跑项目"><a href="#在docker容器里面跑项目" class="headerlink" title="在docker容器里面跑项目"></a>在docker容器里面跑项目</h3><p>因为我刚才在我把本机的80端口映射到docker容器的80端口。我在容器里面有nginx。所以我只要这样配置就能跑起nginx服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen 80;</span><br><span class="line">server_name book.work.dev;(自己定的域名)</span><br><span class="line">index index.html index.htm index.php default.html default.htm default.php;</span><br><span class="line">root  /dockerdata/www/book/public;(容器里面项目的入口,对应的就是我挂载的D:/work/book/public)</span><br></pre></td></tr></table></figure></p><p>自己本机的host这样改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.207  book.work.dev(host域名指向本机的ip,不走公网的dns)</span><br></pre></td></tr></table></figure></p><h3 id="上传镜像到自己的仓库"><a href="#上传镜像到自己的仓库" class="headerlink" title="上传镜像到自己的仓库"></a>上传镜像到自己的仓库</h3><p>比如有时候我们装了个redis啊，装了个mongodb啊，我们想下次使用的时候容器还会有这些东西。也简单的，我这里以阿里云的docker仓库为例。登录<a href="https://dev.aliyun.com/" target="_blank" rel="noopener">阿里云docker仓库</a>.然后创建个本地镜像仓库。然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=xxxxx registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/hsn/test:[镜像版本号]</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/hsn/test:[镜像版本号]</span><br></pre></td></tr></table></figure></p><p><img src="\images/dockerpush.png" alt="docker_push"><br>每次给你的容器打个tag就能推送到阿里云的docker仓库了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近这个docker容器很火。好多牛逼的公司拿它来布置各样的环境啊，布置分布式啊等等。当然，作为码畜的我，玩的没其它人高级。正好公司要求线上环境要跟自己的开发环境保持一致，我就用上了docker&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://Sanit1.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>存在就更新，不存在就插入在并发情景下一个常见的BUG探讨</title>
    <link href="https://Sanit1.github.io/2016/11/16/%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%8F%92%E5%85%A5%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%83%85%E6%99%AF%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84BUG%E6%8E%A2%E8%AE%A8/index.html"/>
    <id>https://Sanit1.github.io/2016/11/16/存在就更新，不存在就插入在并发情景下一个常见的BUG探讨/index.html</id>
    <published>2016-11-16T14:02:00.000Z</published>
    <updated>2019-07-21T14:18:24.651Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有些框架直接在 ORM 里面封装了这种 update or insert 的操作，分析源码，可能是直接用 mysql 的 ON DUPLICATE KEY UPDATE 或者就是先查询判断存不存在,再插入。而今天我们就来讨论后者。</p></blockquote><a id="more"></a><h3 id="BUG举例"><a href="#BUG举例" class="headerlink" title="BUG举例"></a>BUG举例</h3><p>因为这个bug是公司的实际业务逻辑，所以我下面不贴出具体的代码，以伪代码说明。一开始写的时候大家都在赶工，没考虑到各种情况，业务都稳定的情况下，突然有一天，有人告诉我，线上的公司表出现两条一某一样的公司信息，申请人也是同一个，什么都一样。我仔细回来检查，具体的业务代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$company = db-&gt;where(&apos;根据输入的信息&apos;)-&gt;select();</span><br><span class="line">if(!empty($company)&#123;</span><br><span class="line">    db-&gt;update(&apos;根据输入的信息&apos;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    db-&gt;insert(&apos;根据输入的信息&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我一开始看这样的代码感觉没有bug,自己拿号不断去试，结果自己怎么提交最多存进去一条啊，有记录就会更新。我没考虑到并发！！！于是我就开始去用apache自带的ab程序去模拟并发。至于这个工具具体怎么用，我也只会基础的，这里就不继续展开讲了。我就用基础的模拟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c 3 -n 3 -p post.txt application/x-www-form-urlencoded http://xxx.xxx.xxx/xx</span><br></pre></td></tr></table></figure></p><h3 id="目前我的解决办法"><a href="#目前我的解决办法" class="headerlink" title="目前我的解决办法"></a>目前我的解决办法</h3><p>其实这完全是可以避免的 bug，因为既然我们有这样的业务逻辑，但是表结构没这么设计，然后因为有历史遗留数据的问题，所以很蛋疼。先来说说第一种解决办法吧</p><ul><li>修改表结构</li></ul><p>既然业务这么设计，我们只要给表增加唯一索引，这样子，来再多的并发，同样的数据只能有一条。其实大部分情况下，一般的处理办法就是给这个表建立一个或者多个字段的唯一索引。这样数据库就能帮我们保证数据的唯一性。其实我一开始说的 mysql 自带的 ON DUPLICATE KEY UPDATE 也是需要有唯一索引才能用的。</p><ul><li>使用锁</li></ul><p>虽然mysql自带有表锁，但是性能不高。这里可以使用redis的锁，再次一点可以用文件锁。因为php-fpm并不是常驻内存的， 所以只能借助其它东西来代替锁。锁住了之后，只能依次操作， 就避免了并发带来的问题。</p><ul><li>使用异步队列</li></ul><p>这样场景下，并发就像一条直线的数据进来就像这样<br><img src="\images/并发.png" alt="队列"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有些框架直接在 ORM 里面封装了这种 update or insert 的操作，分析源码，可能是直接用 mysql 的 ON DUPLICATE KEY UPDATE 或者就是先查询判断存不存在,再插入。而今天我们就来讨论后者。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MySQL " scheme="https://Sanit1.github.io/tags/MySQL/"/>
    
      <category term="BUG" scheme="https://Sanit1.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>API文档自动生成</title>
    <link href="https://Sanit1.github.io/2016/10/24/API%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/index.html"/>
    <id>https://Sanit1.github.io/2016/10/24/API文档自动生成/index.html</id>
    <published>2016-10-23T17:12:00.000Z</published>
    <updated>2019-07-21T14:19:22.612Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要讲述自动化API文档生成——apidoc。网上有几个篇文章都只是介绍apidoc的，具体怎么在自己的项目中使用以及与其他配合使用都是没介绍的。最近开始玩服务器，了解到了有Windows与Linux之间共享文件的方法，就是samba。然后具体和apidoc结合起来非常好用，所以本文就当做笔记来把它记录下来了</p></blockquote><a id="more"></a><h3 id="apidoc简介"><a href="#apidoc简介" class="headerlink" title="apidoc简介"></a>apidoc简介</h3><p>apidoc是node的一个插件，它的功能就是能让把我们的代码注释生成api文档。它支持php java javascript python等多种语言。因为写接口的同学通常很烦写完接口还得写文档，文档更新又麻烦。apidoc不仅支持项目的版本，也支持api的版本。在我所接触过的文档生成工具里面，这个是我感觉比较好用的。</p><hr><h3 id="apidoc的安装"><a href="#apidoc的安装" class="headerlink" title="apidoc的安装"></a>apidoc的安装</h3><p>apidoc是node的一个插件，那么它的安装就依赖node。node的具体安装我这里就不详细说了，去node官网下包,解压，编译然后安装。直接执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install apidoc -g</span><br></pre></td></tr></table></figure></p><hr><h3 id="samba的安装"><a href="#samba的安装" class="headerlink" title="samba的安装"></a>samba的安装</h3><p>samba的安装也很简单，本人用的是CentOS，我直接执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install samba</span><br></pre></td></tr></table></figure></p><p>就安装好了</p><hr><h3 id="samba的配置"><a href="#samba的配置" class="headerlink" title="samba的配置"></a>samba的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[public]</span><br><span class="line">comment = Public Stuff</span><br><span class="line">path = /share/doc  //你需要共享文件夹的路径</span><br><span class="line">browseable = yes  //可浏览性</span><br><span class="line">guest ok = yes  //是否允许访客</span><br><span class="line">public = yes  //是否可上传</span><br><span class="line">writable = yes  //是否可写</span><br></pre></td></tr></table></figure><p>我自己装的时候也都是这么配置的，注意，这个samba需要你关闭你的防火墙，还得把你共享的目录赋予777的权限（貌似755就够了，我直接给了777）。我这边还遇到过一个很坑爹的问题，就是这样配置了，用Windows访问这个共享目录的时候，要求我输入用户名和密码。其实主要还得把上面的<br><code>security = user</code><br>改成<br><code>security = share</code></p><p>samba也是支持用户管理的，就是可以分配账号密码的，具体的就不展开介绍了。</p><hr><h3 id="apidoc的使用"><a href="#apidoc的使用" class="headerlink" title="apidoc的使用"></a>apidoc的使用</h3><p>　　例如我们在代码里面下了这样的一段注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @api &#123;get post&#125;; /brand/:id/:name/:new 这里中括号里面填的的是请求方式（GET POST OPTION DELETE等），后面填的是路由</span><br><span class="line"> * @apiGroup brandList API接口所在的组名称</span><br><span class="line"> * @apiName  brands  API接口名称</span><br><span class="line"> * @apiVersion 1.0.1 API接口版本</span><br><span class="line"> * @apiDescription  API接口的描述</span><br><span class="line"> * @apiParam (入参) &#123;Number&#123;1-9999&#125;&#125;()这个括号里面的填的参数的组，括号里面相同的会被放在同一个表格里面 id=0 请求参数 大括号里面填的是参数类型 里面的大括号表示值的范围 后面就是参数的名称和默认值</span><br><span class="line"> * @apiParam (入参) &#123;String=“a”,“b”,“c”&#125;; name 品牌名称,等于号表示允许值</span><br><span class="line"> * @apiParam (入参) &#123;Boolean&#125;; new </span><br><span class="line"> * @apiParam (入参) &#123;Number&#125; [test] 如果参数套上[]这样的中括号，表明这个值是个可选的值</span><br><span class="line"> *</span><br><span class="line"> * @apiParamExample &#123;json&#125; 接口返回值</span><br><span class="line"> * &#123;</span><br><span class="line"> *     “code” : 0,</span><br><span class="line"> *     “message” : “success”,</span><br><span class="line"> *     “data” : &#123;</span><br><span class="line"> *         “result” : “ok”;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * @apiSampleRequest  下面就是一个模拟请求器，可以帮我们调试接口</span><br><span class="line"> *     http://www.work.dev</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p><a href="http://apidocjs.com/" target="_blank" rel="noopener">基本上用这些已经足够了，其他的用法可以参考它的官网:</a></p><h3 id="生成apidoc"><a href="#生成apidoc" class="headerlink" title="生成apidoc"></a>生成apidoc</h3><p>假如我在我的控制器里面写了这样一段注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @api &#123;GET&#125; /user_info 获取用户信息接口</span><br><span class="line"> * @apiGroup User</span><br><span class="line"> * @apiVersion 2.0.0</span><br><span class="line"> * @apiDescription 获取用户信息</span><br><span class="line"> *</span><br><span class="line"> * @apiParam (入参) &#123;String&#125; token 登录成功后客户端返回的token</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccessExample Success-Response:</span><br><span class="line"> *  &#123;</span><br><span class="line"> *      &quot;code&quot;: 0,</span><br><span class="line"> *      &quot;message&quot;: &quot;ok&quot;</span><br><span class="line"> *      &quot;data&quot;: &#123;</span><br><span class="line"> *           &quot;name&quot;: &quot;1&quot;,//状态 0:启用 1:停用</span><br><span class="line"> *           &quot;role&quot;: &quot;1&quot;,//1管理员，0是普通员工</span><br><span class="line"> *           &quot;sex&quot;: &quot;1&quot;,//1表示男性，2表示女性</span><br><span class="line"> *      &#125;</span><br><span class="line"> *  &#125;</span><br><span class="line"> *</span><br><span class="line"> * @apiSampleRequest</span><br><span class="line"> * http://api.test.com/user_info</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>先cd到项目里面<br>然后执行这样的语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc -i app/Http/Controllers -o \\xxx.xxx.xxx.xxx\public\</span><br></pre></td></tr></table></figure></p><p>因为我samba共享的是这样一个文件夹，并且在这个里面放文档。然后我们来看下生成的结果:<br><img src="\images/apidoc生成的结果.jpg" alt="apidoc生成的结果"></p><p>这时候我们直接点击index.html可以直接看到这样的静态页面:</p><p><img src="\images/打开页面的结果.jpg" alt="打开页面结果"></p><hr><h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>到这里，我们就已经很方便的能运用apidoc了，我们可以自己直接写好接口的时候直接写注释，一句命令写到开了samba的服务器上，然后直接访问静态页面，如果不想这样赤裸裸的访问静态页面，可以用node或者nginx直接绑上去，这里就不继续展开讲了</p><hr><h3 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h3><p>其实在使用中的时候会发现一些很坑爹的问题，就是GroupName没法用中文，但是其他地方可以用中文。毕竟这个是国外大佬发明的，不是国人的产物，有存在这样的问题也在所难免。我不断的搜，发现github上有人给他提issure。也有给出了解决方案，apidoc的语法其实是支持引用的，所以我们可以这样定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @apiDefine name 测试中文</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p> 然后我们怎么使用呢。可以直接<code>@apiUse name</code>也可以直接在注释里面写<code>name</code>,这样就可以使用中文了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要讲述自动化API文档生成——apidoc。网上有几个篇文章都只是介绍apidoc的，具体怎么在自己的项目中使用以及与其他配合使用都是没介绍的。最近开始玩服务器，了解到了有Windows与Linux之间共享文件的方法，就是samba。然后具体和apidoc结合起来非常好用，所以本文就当做笔记来把它记录下来了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="https://Sanit1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="API文档" scheme="https://Sanit1.github.io/tags/API%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
